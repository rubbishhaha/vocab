<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Mindmap</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }

        #canvas {
            display: block;
            cursor: default;
            user-select: none;
        }

        .input-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            min-width: 300px;
        }

        .input-panel.active {
            display: block;
        }

        .input-panel h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .input-panel input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .input-panel label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }

        .input-panel input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .input-panel button {
            margin-top: 10px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .input-panel .finish-btn {
            background: #4CAF50;
            color: white;
            margin-right: 10px;
        }

        .input-panel .cancel-btn {
            background: #f44336;
            color: white;
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 15px 30px;
            border-radius: 4px;
            display: none;
            z-index: 2000;
        }

        .notification.active {
            display: block;
        }

        .notification button {
            margin: 10px 5px 0;
            padding: 5px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .notification .confirm-btn {
            background: #f44336;
            color: white;
        }

        .notification .cancel-btn {
            background: #666;
            color: white;
        }

        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }

        .edit-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .edit-panel.active {
            display: block;
        }

        .edit-panel h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .edit-panel .node-edit-item {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .edit-panel .node-edit-item h4 {
            margin-bottom: 8px;
            color: #555;
            font-size: 14px;
        }

        .edit-panel input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .edit-panel input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .edit-panel .overall-settings {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .edit-panel .overall-settings h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .edit-panel button {
            margin-top: 10px;
            margin-right: 10px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .edit-panel .save-btn {
            background: #4CAF50;
            color: white;
        }

        .edit-panel .cancel-btn {
            background: #f44336;
            color: white;
        }

        .edit-panel .apply-all-btn {
            background: #2196F3;
            color: white;
        }

        .control-panel {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 999;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-panel h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }

        .control-panel button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #4CAF50;
            color: white;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .control-panel button:hover {
            background: #45a049;
        }

        .control-panel button:active {
            transform: scale(0.95);
        }

        .control-panel .btn-edit { background: #2196F3; }
        .control-panel .btn-edit:hover { background: #0b7dda; }

        .control-panel .btn-delete { background: #f44336; }
        .control-panel .btn-delete:hover { background: #da190b; }

        .control-panel .btn-copy { background: #FF9800; }
        .control-panel .btn-copy:hover { background: #e68900; }

        .control-panel .btn-nav { background: #9C27B0; }
        .control-panel .btn-nav:hover { background: #7b1fa2; }

        .control-panel .btn-view { background: #607D8B; }
        .control-panel .btn-view:hover { background: #455a64; }

        .control-panel-section {
            border-top: 1px solid #eee;
            padding-top: 8px;
            margin-top: 5px;
        }

        .control-panel-section:first-child {
            border-top: none;
            margin-top: 0;
            padding-top: 0;
        }

        @media (max-width: 768px) {
            .control-panel {
                right: 5px;
                padding: 10px;
                max-height: 85vh;
            }
            
            .control-panel button {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .info {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="input-panel" id="inputPanel">
        <h3>æ–°å¢ç¯€é»</h3>
        <label>åç¨±:</label>
        <input type="text" id="nodeNameInput" placeholder="è¼¸å…¥ç¯€é»åç¨±">
        <label>é¡è‰²:</label>
        <input type="color" id="nodeColorInput" value="#ff6b6b">
        <div>
            <button class="finish-btn" onclick="finishAddNode()">å®Œæˆ</button>
            <button class="cancel-btn" onclick="cancelAddNode()">å–æ¶ˆ</button>
        </div>
    </div>

    <div class="notification" id="notification">
        <p id="notificationText"></p>
        <div>
            <button class="confirm-btn" onclick="confirmDelete()">ç¢ºèª</button>
            <button class="cancel-btn" onclick="cancelDelete()">å–æ¶ˆ</button>
        </div>
    </div>

    <div class="info">
        <div>å·¦éµæ‹–æ›³: é¸æ“‡å¤šå€‹ç¯€é»</div>
        <div>Shift+é»æ“Š: è¿½åŠ /å–æ¶ˆé¸æ“‡</div>
        <div>å·¦éµé»æ“Š: é€²å…¥è©²å±¤ç´š</div>
        <div>å·¦éµé•·æŒ‰: æ‹–å‹•ç¯€é»</div>
        <div>å³éµé»æ“Š(ç„¡é¸æ“‡): è¿”å›ä¸Šå±¤</div>
        <div>å³éµé»æ“Š(æœ‰é¸æ“‡): ç·¨è¼¯ç¯€é»</div>
        <div>WASD: ç§»å‹•è¦–é‡</div>
        <div>Space: æ–°å¢ç¯€é»</div>
        <div>Shift+Space: åˆªé™¤</div>
        <div>Ctrl+C/X/V/Z: è¤‡è£½/å‰ªä¸‹/è²¼ä¸Š/å¾©åŸ</div>
    </div>

    <div class="control-panel">
        <h4>æ§åˆ¶é¢æ¿</h4>
        
        <div class="control-panel-section">
            <button onclick="btnAddNode()" title="æ–°å¢ç¯€é»">â• æ–°å¢</button>
            <button class="btn-edit" onclick="btnEditNode()" title="ç·¨è¼¯é¸ä¸­ç¯€é»">âœï¸ ç·¨è¼¯</button>
            <button class="btn-delete" onclick="btnDeleteNode()" title="åˆªé™¤ç¯€é»">ğŸ—‘ï¸ åˆªé™¤</button>
        </div>
        
        <div class="control-panel-section">
            <button class="btn-copy" onclick="btnCopy()" title="è¤‡è£½">ğŸ“‹ è¤‡è£½</button>
            <button class="btn-copy" onclick="btnCut()" title="å‰ªä¸‹">âœ‚ï¸ å‰ªä¸‹</button>
            <button class="btn-copy" onclick="btnPaste()" title="è²¼ä¸Š">ğŸ“Œ è²¼ä¸Š</button>
            <button class="btn-copy" onclick="btnUndo()" title="å¾©åŸ">â†©ï¸ å¾©åŸ</button>
        </div>
        
        <div class="control-panel-section">
            <button class="btn-nav" onclick="btnGoBack()" title="è¿”å›ä¸Šå±¤">â¬†ï¸ ä¸Šå±¤</button>
        </div>
        
        <div class="control-panel-section">
            <button class="btn-view" onclick="btnMoveView('up')" title="å‘ä¸Šç§»å‹•è¦–é‡">â¬†ï¸ ä¸Š</button>
            <button class="btn-view" onclick="btnMoveView('down')" title="å‘ä¸‹ç§»å‹•è¦–é‡">â¬‡ï¸ ä¸‹</button>
            <button class="btn-view" onclick="btnMoveView('left')" title="å‘å·¦ç§»å‹•è¦–é‡">â¬…ï¸ å·¦</button>
            <button class="btn-view" onclick="btnMoveView('right')" title="å‘å³ç§»å‹•è¦–é‡">â¡ï¸ å³</button>
        </div>
    </div>

    <div class="edit-panel" id="editPanel">
        <h3>ç·¨è¼¯ç¯€é»</h3>
        
        <div class="overall-settings">
            <h4>æ•´é«”è¨­å®š</h4>
            <label>æ‰€æœ‰é¸ä¸­ç¯€é»çš„åç¨±:</label>
            <input type="text" id="overallNameInput" placeholder="ç•™ç©ºä¸æ›´æ”¹">
            <label>æ‰€æœ‰é¸ä¸­ç¯€é»çš„é¡è‰²:</label>
            <input type="color" id="overallColorInput">
            <button class="apply-all-btn" onclick="applyOverallSettings()">æ‡‰ç”¨è‡³æ‰€æœ‰</button>
        </div>
        
        <div id="individualEditsList"></div>
        
        <div>
            <button class="save-btn" onclick="saveNodeEdits()">å„²å­˜</button>
            <button class="cancel-btn" onclick="cancelNodeEdits()">å–æ¶ˆ</button>
        </div>
    </div>

    <script>
        // æ•¸æ“šçµæ§‹
        class MindMapNode {
            constructor(name, color, parent = null) {
                this.name = name;
                this.color = color;
                this.children = {};
                this.parent = parent;
                this.id = Date.now() + Math.random();
            }

            addChild(name, color) {
                const child = new MindMapNode(name, color, this);
                this.children[child.id] = child;
                return child;
            }

            removeChild(childId) {
                delete this.children[childId];
            }

            getDepth() {
                let depth = 0;
                let current = this;
                while (current.parent) {
                    depth++;
                    current = current.parent;
                }
                return depth;
            }
        }

        // å…¨å±€è®Šé‡
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        // localStorage å­˜å–å‡½æ•¸
        const STORAGE_KEY = 'mindmap_data';
        
        function saveToLocalStorage() {
            try {
                const data = {
                    tree: serializeNode(rootNode),
                    currentCenterId: currentCenterNode.id,
                    viewOffset: viewOffset,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                if (data) {
                    const parsed = JSON.parse(data);
                    return parsed;
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
            return null;
        }
        
        function serializeNode(node) {
            return {
                id: node.id,
                name: node.name,
                color: node.color,
                children: Object.values(node.children).map(child => serializeNode(child))
            };
        }
        
        function deserializeNode(data, parent = null) {
            const node = new MindMapNode(data.name, data.color, parent);
            node.id = data.id;
            data.children.forEach(childData => {
                const child = deserializeNode(childData, node);
                node.children[child.id] = child;
            });
            return node;
        }
        
        function findNodeById(root, id) {
            if (root.id === id) return root;
            for (let child of Object.values(root.children)) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
            return null;
        }
        // åˆå§‹åŒ–æ ¹ç¯€é»
        let rootNode;
        let loadedData = loadFromLocalStorage();
        
        if (loadedData && loadedData.tree) {
            // å¾ localStorage è¼‰å…¥
            rootNode = deserializeNode(loadedData.tree);
        } else {
            // ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼Œå‰µå»ºé è¨­çš„ main ç¯€é»
            rootNode = new MindMapNode('main', '#ff6b6b', null);
            // ä¿å­˜åˆå§‹ç‹€æ…‹
            setTimeout(() => saveToLocalStorage(), 100);
        }


        let currentCenterNode = rootNode;
        if (loadedData && loadedData.currentCenterId) {
            const foundNode = findNodeById(rootNode, loadedData.currentCenterId);
            if (foundNode) currentCenterNode = foundNode;
        }
        
        let selectedNodes = new Set(); // æ¡†é¸çš„ç¯€é»
        let actualSelectedNodes = new Set(); // å¯¦éš›é¸ä¸­çš„ç¯€é»ï¼ˆè€ƒæ…®åˆ†æ”¯é‚è¼¯ï¼‰
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragCurrent = { x: 0, y: 0 };
        let nodePositions = new Map();
        let hoveredNode = null;
        let viewOffset = loadedData && loadedData.viewOffset ? loadedData.viewOffset : { x: 0, y: 0 };
        let isPanelOpen = false; // è¿½è¹¤é¢æ¿æ˜¯å¦é–‹å•Ÿ
        
        // æ‹–å‹•ç¯€é»ç›¸é—œ
        let isDraggingNode = false;
        let draggedNode = null;
        let dragNodeStart = { x: 0, y: 0 };
        let dragNodeOffset = { x: 0, y: 0 };
        let nodePositionsBackup = new Map();
        let dragNodeStartTime = 0;
        let lastDragEndTime = 0; // ä¸Šæ¬¡æ‹–å‹•çµæŸæ™‚é–“
        let permanentNodeOffsets = new Map(); // æ°¸ä¹…çš„ç¯€é»åç§»

        // å‰ªè²¼ç°¿å’Œæ­·å²
        let clipboard = null;
        let clipboardMode = null; // 'copy' or 'cut'
        let history = [];
        let historyIndex = -1;

        // é¡è‰²ç”Ÿæˆ
        const layerColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9', '#74b9ff', '#a29bfe'];
        
        function getLayerColor(depth) {
            return layerColors[depth % layerColors.length];
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            draw();
        }

        // ç¹ªè£½å‡½æ•¸
        function draw() {
            ctx.clearRect(0, 0, width, height);
            nodePositions.clear();

            // ç¹ªè£½ä¸­å¿ƒç¯€é»
            const centerX = width / 2 + viewOffset.x;
            const centerY = height / 2 + viewOffset.y;
            const centerDepth = currentCenterNode.getDepth();

            // å…ˆç¹ªè£½æ‰€æœ‰é€£ç·šï¼ˆåœ¨åº•å±¤ï¼‰
            drawConnectionsOnly(currentCenterNode, centerX, centerY, centerDepth, 0, null);
            
            // å†ç¹ªè£½æ‰€æœ‰ç¯€é»ï¼ˆåœ¨ä¸Šå±¤ï¼‰
            drawNode(centerX, centerY, currentCenterNode, centerDepth, true);
            drawNodesOnly(currentCenterNode, centerX, centerY, centerDepth, 0, null);

            // ç¹ªè£½é¸æ“‡æ¡†
            if (isDragging) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    dragStart.x,
                    dragStart.y,
                    dragCurrent.x - dragStart.x,
                    dragCurrent.y - dragStart.y
                );
                ctx.setLineDash([]);
            }
        }

        function drawNode(x, y, node, baseDepth, isCenter = false) {
            // æ‡‰ç”¨æ‹–å‹•åç§»
            const offset = getNodeDragOffset(node.id);
            x += offset.x;
            y += offset.y;
            
            const nodeDepth = node.getDepth() - baseDepth;
            const minSize = isCenter ? 80 : 60;
            const radius = 8; // åœ“è§’åŠå¾‘
            const padding = 10;
            const lineHeight = 18;
            const maxWidth = minSize - padding * 2;
            let color = node.color;

            // æ‡¸åœæ•ˆæœ
            if (hoveredNode && hoveredNode.id === node.id) {
                color = '#ffeb3b'; // é»ƒè‰²é«˜äº®
            }
            
            // æ‹–å‹•ä¸­çš„ç¯€é»åŠé€æ˜é¡¯ç¤º
            if (isDraggingNode && draggedNode && draggedNode.id === node.id) {
                ctx.globalAlpha = 0.7;
            }

            // è¨ˆç®—æ–‡å­—æ›è¡Œ
            ctx.font = isCenter ? 'bold 16px Arial' : '14px Arial';
            const wrapResult = wrapText(node.name, maxWidth);
            const lines = wrapResult.lines;
            const actualMaxWidth = wrapResult.maxWidth;
            
            // è¨ˆç®—å¯¦éš›æ–¹å¡Šå¤§å°
            const textHeight = lines.length * lineHeight;
            const blockHeight = Math.max(minSize, textHeight + padding * 2);
            const blockWidth = Math.max(minSize, actualMaxWidth + padding * 2);

            // ç¹ªè£½åœ“è§’æ–¹å¡Š
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x - blockWidth/2, y - blockHeight/2, blockWidth, blockHeight, radius);
            ctx.fill();

            // æ¡†é¸çš„ç¯€é»é¡¯ç¤ºç¶ è‰²é‚Šæ¡†
            if (selectedNodes.has(node.id)) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.roundRect(x - blockWidth/2 - 2, y - blockHeight/2 - 2, blockWidth + 4, blockHeight + 4, radius);
                ctx.stroke();
            }

            // å¯¦éš›é¸ä¸­çš„ç¯€é»ï¼ˆåŒ…å«åˆ†æ”¯é‚è¼¯ï¼‰é¡¯ç¤ºæ›´ç²—çš„é‚Šæ¡†
            if (actualSelectedNodes.has(node.id) && !selectedNodes.has(node.id)) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(x - blockWidth/2 - 1, y - blockHeight/2 - 1, blockWidth + 2, blockHeight + 2, radius);
                ctx.stroke();
            }

            // ç¹ªè£½æ–‡å­—ï¼ˆå¤šè¡Œï¼‰
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const startY = y - (lines.length - 1) * lineHeight / 2;
            lines.forEach((line, i) => {
                ctx.fillText(line, x, startY + i * lineHeight);
            });
            
            // é‡ç½®é€æ˜åº¦
            ctx.globalAlpha = 1.0;

            // è¨˜éŒ„ä½ç½®ï¼ˆä½¿ç”¨å¯¦éš›å¤§å°ï¼‰
            nodePositions.set(node.id, { x, y, size: Math.max(blockWidth, blockHeight), node });
        }
        
        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            let actualMaxWidth = 0;
            
            words.forEach((word, index) => {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine.length > 0) {
                    // ç•¶å‰è¡ŒåŠ ä¸Šé€™å€‹å–®è©è¶…éå¯¬åº¦ï¼Œæ›è¡Œ
                    const lineMetrics = ctx.measureText(currentLine);
                    actualMaxWidth = Math.max(actualMaxWidth, lineMetrics.width);
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) {
                const lineMetrics = ctx.measureText(currentLine);
                actualMaxWidth = Math.max(actualMaxWidth, lineMetrics.width);
                lines.push(currentLine);
            }
            
            return {
                lines: lines.length > 0 ? lines : [text],
                maxWidth: actualMaxWidth > 0 ? actualMaxWidth : ctx.measureText(text).width
            };
        }

        // åªç¹ªè£½é€£ç·š
        function drawConnectionsOnly(parentNode, parentX, parentY, baseDepth, currentLayer, parentAngle) {
            if (currentLayer >= 2) return;
            
            // æ‡‰ç”¨çˆ¶ç¯€é»æ‹–å‹•åç§»
            const parentOffset = getNodeDragOffset(parentNode.id);
            parentX += parentOffset.x;
            parentY += parentOffset.y;
            
            const children = Object.values(parentNode.children);
            if (children.length === 0) return;
            
            const radius = 200 + currentLayer * 150;
            const isCenter = (currentLayer === 0);
            const angleStep = isCenter ? 
                (Math.PI * 2) / children.length : 
                (Math.PI * 2) / (children.length + 1);
            
            let startAngle;
            if (isCenter) {
                startAngle = -Math.PI / 2;
            } else {
                // å­å¡Šçš„èµ·å§‹è§’åº¦åŸºæ–¼çˆ¶é€£ç·šè§’åº¦
                // çˆ¶é€£ç·šå¾å­å¡Šè¦–è§’ä¾†çœ‹æ˜¯ parentAngle + PIï¼ˆåæ–¹å‘ï¼‰
                const parentDirection = parentAngle + Math.PI;
                startAngle = parentDirection + angleStep;
            }
            
            children.forEach((child, index) => {
                const angle = startAngle + angleStep * index;
                const baseX = parentX + Math.cos(angle) * radius;
                const baseY = parentY + Math.sin(angle) * radius;
                
                // æ‡‰ç”¨å­ç¯€é»æ‹–å‹•åç§»
                const childOffset = getNodeDragOffset(child.id);
                const childX = baseX + childOffset.x;
                const childY = baseY + childOffset.y;
                
                // ç¹ªè£½é€£ç·šï¼ˆå¾çˆ¶ç¯€é»çš„å¯¦éš›ä½ç½®åˆ°å­ç¯€é»çš„å¯¦éš›ä½ç½®ï¼‰
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(parentX, parentY);
                ctx.lineTo(childX, childY);
                ctx.stroke();
                
                // éæ­¸ç¹ªè£½å­ç¯€é»çš„é€£ç·šï¼ˆå‚³éåŸºç¤ä½ç½®ï¼Œä¸å«åç§»ï¼‰
                drawConnectionsOnly(child, baseX, baseY, baseDepth, currentLayer + 1, angle);
            });
        }
        
        // åªç¹ªè£½ç¯€é»
        function drawNodesOnly(parentNode, parentX, parentY, baseDepth, currentLayer, parentAngle) {
            if (currentLayer >= 2) return;
            
            // æ‡‰ç”¨çˆ¶ç¯€é»æ‹–å‹•åç§»
            const parentOffset = getNodeDragOffset(parentNode.id);
            parentX += parentOffset.x;
            parentY += parentOffset.y;
            
            const children = Object.values(parentNode.children);
            if (children.length === 0) return;
            
            const radius = 200 + currentLayer * 150;
            const isCenter = (currentLayer === 0);
            const angleStep = isCenter ? 
                (Math.PI * 2) / children.length : 
                (Math.PI * 2) / (children.length + 1);
            
            let startAngle;
            if (isCenter) {
                startAngle = -Math.PI / 2;
            } else {
                const parentDirection = parentAngle + Math.PI;
                startAngle = parentDirection + angleStep;
            }
            
            children.forEach((child, index) => {
                const angle = startAngle + angleStep * index;
                const x = parentX + Math.cos(angle) * radius;
                const y = parentY + Math.sin(angle) * radius;
                
                // ç¹ªè£½ç¯€é»
                drawNode(x, y, child, baseDepth);
                
                // éæ­¸ç¹ªè£½å­ç¯€é»ï¼ˆå‚³éå¯¦éš›ä½ç½®ï¼‰
                drawNodesOnly(child, x, y, baseDepth, currentLayer + 1, angle);
            });
        }

        // æª¢æŸ¥é»æ˜¯å¦åœ¨çŸ©å½¢å…§
        function isPointInRect(px, py, x, y, size) {
            return px >= x - size/2 && px <= x + size/2 &&
                   py >= y - size/2 && py <= y + size/2;
        }

        // ç²å–é»æ“Šçš„ç¯€é»
        function getNodeAtPosition(x, y) {
            for (let [id, pos] of nodePositions) {
                if (isPointInRect(x, y, pos.x, pos.y, pos.size)) {
                    return pos.node;
                }
            }
            return null;
        }

        // ç²å–é¸æ“‡æ¡†å…§çš„ç¯€é»
        function getNodesInSelection(x1, y1, x2, y2) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);

            const nodes = [];
            for (let [id, pos] of nodePositions) {
                if (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY) {
                    nodes.push(pos.node);
                }
            }
            return nodes;
        }

        // æ»‘é¼ äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // åªè™•ç†å·¦éµ
            
            const node = getNodeAtPosition(e.clientX, e.clientY);
            dragNodeStartTime = Date.now();
            
            if (node) {
                // é»æ“Šç¯€é»ï¼Œå¯èƒ½æ˜¯è¦æ‹–å‹•
                draggedNode = node;
                dragNodeStart = { x: e.clientX, y: e.clientY };
                const pos = nodePositions.get(node.id);
                dragNodeOffset = { x: e.clientX - pos.x, y: e.clientY - pos.y };
            } else {
                // é»æ“Šç©ºç™½ï¼Œé–‹å§‹æ¡†é¸
                isDragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
                dragCurrent = { x: e.clientX, y: e.clientY };
                selectedNodes.clear();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                dragCurrent = { x: e.clientX, y: e.clientY };
                draw();
            } else if (draggedNode && Date.now() - dragNodeStartTime > 150) {
                // é•·æŒ‰è¶…é150msï¼Œé–‹å§‹æ‹–å‹•ç¯€é»
                const dx = e.clientX - dragNodeStart.x;
                const dy = e.clientY - dragNodeStart.y;
                
                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    isDraggingNode = true;
                    dragCurrent = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                }
                draw();
            } else {
                // æª¢æŸ¥é¼ æ¨™æ‡¸åœ
                const node = getNodeAtPosition(e.clientX, e.clientY);
                if (node !== hoveredNode) {
                    hoveredNode = node;
                    draw();
                }
                canvas.style.cursor = node ? 'pointer' : 'default';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDraggingNode) {
                // ä¿å­˜æ‹–å‹•åç§»åˆ°æ°¸ä¹…è¨˜éŒ„ï¼ˆåªç‚ºæ‹–å‹•çš„ç¯€é»ä¿å­˜ï¼‰
                const dx = dragCurrent.x - dragNodeStart.x;
                const dy = dragCurrent.y - dragNodeStart.y;
                const currentOffset = permanentNodeOffsets.get(draggedNode.id) || { x: 0, y: 0 };
                permanentNodeOffsets.set(draggedNode.id, {
                    x: currentOffset.x + dx,
                    y: currentOffset.y + dy
                });
                
                // çµæŸæ‹–å‹•ç¯€é»
                isDraggingNode = false;
                draggedNode = null;
                lastDragEndTime = Date.now();
                canvas.style.cursor = 'default';
                draw();
            } else if (isDragging) {
                const nodes = getNodesInSelection(dragStart.x, dragStart.y, e.clientX, e.clientY);
                if (!e.shiftKey) {
                    selectedNodes.clear();
                }
                nodes.forEach(node => selectedNodes.add(node.id));
                updateActualSelectedNodes();
                isDragging = false;
                draw();
            } else if (draggedNode) {
                // çŸ­æŒ‰ï¼Œä¸æ˜¯æ‹–å‹•ï¼Œæ¸…é™¤æ‹–å‹•ç‹€æ…‹
                draggedNode = null;
            }
        });

        canvas.addEventListener('click', (e) => {
            if (isDragging || isDraggingNode) return;
            
            // å¦‚æœå‰›æ‹–å‹•å®Œï¼Œç­‰å¾… 300ms æ‰å…è¨±é»æ“Šé€²å…¥
            if (Date.now() - lastDragEndTime < 300) return;
            
            const node = getNodeAtPosition(e.clientX, e.clientY);
            if (node) {
                if (e.shiftKey) {
                    // Shift+é»æ“Šè¿½åŠ é¸æ“‡
                    if (selectedNodes.has(node.id)) {
                        selectedNodes.delete(node.id);
                    } else {
                        selectedNodes.add(node.id);
                    }
                    updateActualSelectedNodes();
                    draw();
                } else if (node !== currentCenterNode) {
                    // é€²å…¥è©²å±¤ç´š
                    currentCenterNode = node;
                    selectedNodes.clear();
                    actualSelectedNodes.clear();
                    saveHistory();
                    saveToLocalStorage();
                    draw();
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            const node = getNodeAtPosition(e.clientX, e.clientY);
            
            // Shift+å³éµï¼šå–æ¶ˆé¸æ“‡ç¯€é»
            if (e.shiftKey && node && selectedNodes.has(node.id)) {
                selectedNodes.delete(node.id);
                updateActualSelectedNodes();
                draw();
                return;
            }
            
            // å¦‚æœæœ‰é¸ä¸­çš„ç¯€é»ï¼Œæ‰“é–‹ç·¨è¼¯é¢æ¿
            if (selectedNodes.size > 0) {
                openEditPanel();
                return;
            }
            
            if (!node && currentCenterNode.parent) {
                // è¿”å›ä¸Šå±¤
                currentCenterNode = currentCenterNode.parent;
                selectedNodes.clear();
                actualSelectedNodes.clear();
                saveHistory();
                saveToLocalStorage();
                draw();
            }
        });

        // æ›´æ–°å¯¦éš›é¸ä¸­çš„ç¯€é»ï¼ˆè€ƒæ…®åˆ†æ”¯é‚è¼¯ï¼‰
        function updateActualSelectedNodes() {
            actualSelectedNodes.clear();
            
            if (selectedNodes.size === 0) return;
            
            const selectedArray = Array.from(selectedNodes).map(id => {
                for (let [_, pos] of nodePositions) {
                    if (pos.node.id === id) return pos.node;
                }
            }).filter(n => n);
            
            // ç‚ºæ¯å€‹é¸ä¸­çš„ç¯€é»è¨ˆç®—å…¶å¯¦éš›åŒ…å«çš„ç¯€é»
            selectedArray.forEach(node => {
                actualSelectedNodes.add(node.id);
                
                // æª¢æŸ¥æ˜¯å¦æœ‰é¸ä¸­è©²ç¯€é»çš„å­ç¯€é»
                const hasSelectedChild = selectedArray.some(other => {
                    return other !== node && isDescendant(other, node);
                });
                
                if (!hasSelectedChild) {
                    // å¦‚æœæ²’æœ‰é¸ä¸­å­ç¯€é»ï¼Œå‰‡åŒ…å«æ‰€æœ‰å­ç¯€é»
                    addAllDescendants(node, actualSelectedNodes);
                } else {
                    // å¦‚æœæœ‰é¸ä¸­å­ç¯€é»ï¼Œå‰‡åªåŒ…å«é¸ä¸­çš„é‚£äº›åˆ†æ”¯
                    // ä¸åšä»»ä½•äº‹ï¼Œè®“éæ­¸è™•ç†
                }
            });
        }
        
        function isDescendant(node, ancestor) {
            let current = node.parent;
            while (current) {
                if (current.id === ancestor.id) return true;
                current = current.parent;
            }
            return false;
        }
        
        function addAllDescendants(node, set) {
            Object.values(node.children).forEach(child => {
                set.add(child.id);
                addAllDescendants(child, set);
            });
        }

        // éµç›¤äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            // å¦‚æœç„¦é»åœ¨è¼¸å…¥å…ƒç´ ä¸Šï¼Œå…è¨±æ‰€æœ‰æŒ‰éµ
            const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
            
            if (isPanelOpen) {
                if (e.code === 'Escape') {
                    e.preventDefault();
                    cancelAddNode();
                    cancelDelete();
                    return;
                }
                // å¦‚æœç„¦é»åœ¨è¼¸å…¥æ¡†ï¼Œå…è¨±æ‰€æœ‰æŒ‰éµç”¨æ–¼æ‰“å­—
                if (isInputFocused) {
                    return;
                }
                // ç„¦é»ä¸åœ¨è¼¸å…¥æ¡†æ™‚ï¼Œé˜»æ­¢å¿ƒæ™ºåœ–æ§åˆ¶éµ
                e.preventDefault();
                return;
            }
            
            // WASD - ç§»å‹•è¦–é‡
            if (e.code === 'KeyW') {
                e.preventDefault();
                viewOffset.y += 30;
                saveToLocalStorage();
                draw();
            }
            else if (e.code === 'KeyS') {
                e.preventDefault();
                viewOffset.y -= 30;
                saveToLocalStorage();
                draw();
            }
            else if (e.code === 'KeyA') {
                e.preventDefault();
                viewOffset.x += 30;
                saveToLocalStorage();
                draw();
            }
            else if (e.code === 'KeyD') {
                e.preventDefault();
                viewOffset.x -= 30;
                saveToLocalStorage();
                draw();
            }
            
            // Space - æ–°å¢ç¯€é»
            else if (e.code === 'Space' && !e.shiftKey && !e.ctrlKey) {
                e.preventDefault();
                openAddNodePanel();
            }
            
            // Shift + Space - åˆªé™¤ç¯€é»
            else if (e.code === 'Space' && e.shiftKey) {
                e.preventDefault();
                openDeleteConfirmation();
            }
            
            // Ctrl + C - è¤‡è£½
            else if (e.code === 'KeyC' && e.ctrlKey && !e.shiftKey) {
                e.preventDefault();
                copyNodes();
            }
            
            // Ctrl + X - å‰ªä¸‹
            else if (e.code === 'KeyX' && e.ctrlKey) {
                e.preventDefault();
                cutNodes();
            }
            
            // Ctrl + V - è²¼ä¸Š
            else if (e.code === 'KeyV' && e.ctrlKey) {
                e.preventDefault();
                pasteNodes();
            }
            
            // Ctrl + Z - å¾©åŸ
            else if (e.code === 'KeyZ' && e.ctrlKey) {
                e.preventDefault();
                undo();
            }
        });

        // æ–°å¢ç¯€é»é¢æ¿
        function openAddNodePanel() {
            const panel = document.getElementById('inputPanel');
            const nameInput = document.getElementById('nodeNameInput');
            const colorInput = document.getElementById('nodeColorInput');
            
            const targetNodes = selectedNodes.size > 0 ? 
                Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id) return pos.node;
                    }
                }).filter(n => n) : [currentCenterNode];
            
            const depth = targetNodes[0].getDepth() + 1;
            colorInput.value = getLayerColor(depth);
            nameInput.value = '';
            panel.classList.add('active');
            isPanelOpen = true;
            nameInput.focus();
        }

        function finishAddNode() {
            const panel = document.getElementById('inputPanel');
            const name = document.getElementById('nodeNameInput').value.trim();
            const color = document.getElementById('nodeColorInput').value;
            
            if (!name) {
                alert('è«‹è¼¸å…¥ç¯€é»åç¨±');
                return;
            }

            const targetNodes = selectedNodes.size > 0 ? 
                Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id) return pos.node;
                    }
                }).filter(n => n) : [currentCenterNode];

            targetNodes.forEach(node => {
                node.addChild(name, color);
            });

            saveHistory();
            saveToLocalStorage();
            panel.classList.remove('active');
            isPanelOpen = false;
            selectedNodes.clear();
            actualSelectedNodes.clear();
            draw();
        }

        function cancelAddNode() {
            document.getElementById('inputPanel').classList.remove('active');
            isPanelOpen = false;
        }

        // åˆªé™¤ç¢ºèª
        function openDeleteConfirmation() {
            const targetNode = selectedNodes.size > 0 ? 
                Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id) return pos.node;
                    }
                })[0] : currentCenterNode;

            if (!targetNode) return;

            const notification = document.getElementById('notification');
            const text = document.getElementById('notificationText');
            text.textContent = `ç¢ºå®šè¦åˆªé™¤ "${targetNode.name}" åŠå…¶æ‰€æœ‰å­ç¯€é»å—ï¼Ÿ`;
            notification.classList.add('active');
            isPanelOpen = true;
        }

        function confirmDelete() {
            const targetNodes = selectedNodes.size > 0 ? 
                Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id) return pos.node;
                    }
                }).filter(n => n) : [currentCenterNode];

            targetNodes.forEach(node => {
                if (node.parent) {
                    node.parent.removeChild(node.id);
                    if (node === currentCenterNode && node.parent) {
                        currentCenterNode = node.parent;
                    }
                } else if (node === rootNode) {
                    // æ¸…ç©ºæ ¹ç¯€é»çš„å­ç¯€é»
                    node.children = {};
                }
            });

            saveHistory();
            saveToLocalStorage();
            selectedNodes.clear();
            actualSelectedNodes.clear();
            document.getElementById('notification').classList.remove('active');
            isPanelOpen = false;
            draw();
        }

        function cancelDelete() {
            document.getElementById('notification').classList.remove('active');
            isPanelOpen = false;
        }

        // è¤‡è£½/å‰ªä¸‹/è²¼ä¸Š
        function copyNodes() {
            if (selectedNodes.size > 0) {
                updateActualSelectedNodes();
                
                // åªè¤‡è£½æ¡†é¸çš„ç¯€é»ï¼ˆä¸åŒ…æ‹¬è‡ªå‹•åŒ…å«çš„åˆ†æ”¯ï¼‰
                clipboard = Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id) {
                            // è¤‡è£½ç¯€é»åŠå…¶å®Œæ•´å­æ¨¹
                            return cloneNodeWithBranches(pos.node);
                        }
                    }
                }).filter(n => n);
                clipboardMode = 'copy';
            }
        }

        function cutNodes() {
            if (selectedNodes.size > 0) {
                updateActualSelectedNodes();
                
                // å‰ªä¸‹æ™‚åªå‰ªä¸‹æ¡†é¸çš„ç¯€é»ï¼Œä¸åŒ…æ‹¬æ ¹ç¯€é»
                clipboard = Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id && pos.node.parent) {
                            return pos.node;
                        }
                    }
                }).filter(n => n);
                clipboardMode = 'cut';
            }
        }
        
        function cloneNodeWithBranches(node) {
            const cloned = new MindMapNode(node.name, node.color, null);
            Object.values(node.children).forEach(child => {
                const clonedChild = cloneNodeWithBranches(child);
                clonedChild.parent = cloned;
                cloned.children[clonedChild.id] = clonedChild;
            });
            return cloned;
        }

        function pasteNodes() {
            if (!clipboard || clipboard.length === 0) return;

            const targetNodes = selectedNodes.size > 0 ? 
                Array.from(selectedNodes).map(id => {
                    for (let [_, pos] of nodePositions) {
                        if (pos.node.id === id) return pos.node;
                    }
                }).filter(n => n) : [currentCenterNode];

            targetNodes.forEach(targetNode => {
                clipboard.forEach(clipNode => {
                    if (clipboardMode === 'cut' && clipNode.parent) {
                        clipNode.parent.removeChild(clipNode.id);
                        clipNode.parent = targetNode;
                        targetNode.children[clipNode.id] = clipNode;
                    } else {
                        const cloned = cloneNodeWithBranches(clipNode);
                        cloned.parent = targetNode;
                        targetNode.children[cloned.id] = cloned;
                    }
                });
            });

            if (clipboardMode === 'cut') {
                clipboard = null;
                clipboardMode = null;
            }

            saveHistory();
            saveToLocalStorage();
            selectedNodes.clear();
            actualSelectedNodes.clear();
            draw();
        }

        // æ­·å²è¨˜éŒ„
        function saveHistory() {
            const state = {
                root: cloneNodeWithBranches(rootNode),
                center: currentCenterNode.id
            };
            history = history.slice(0, historyIndex + 1);
            history.push(state);
            historyIndex++;
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                // é€™è£¡ç°¡åŒ–è™•ç†ï¼Œå¯¦éš›éœ€è¦å®Œæ•´çš„ç‹€æ…‹æ¢å¾©
                draw();
            }
        }

        // åˆå§‹åŒ–
        window.addEventListener('resize', resize);
        resize();
        saveHistory();

        // ç·¨è¼¯é¢æ¿ç›¸é—œå‡½æ•¸
        let editingNodes = [];
        
        function openEditPanel() {
            const panel = document.getElementById('editPanel');
            const individualList = document.getElementById('individualEditsList');
            
            // ç²å–é¸ä¸­çš„ç¯€é»
            editingNodes = Array.from(selectedNodes).map(id => {
                for (let [_, pos] of nodePositions) {
                    if (pos.node.id === id) return pos.node;
                }
            }).filter(n => n);
            
            if (editingNodes.length === 0) return;
            
            // æ¸…ç©ºå€‹åˆ¥ç·¨è¼¯åˆ—è¡¨
            individualList.innerHTML = '';
            
            // ç‚ºæ¯å€‹ç¯€é»å‰µå»ºç·¨è¼¯é …
            editingNodes.forEach((node, index) => {
                const item = document.createElement('div');
                item.className = 'node-edit-item';
                item.innerHTML = `
                    <h4>ç¯€é» ${index + 1}: ${node.name}</h4>
                    <label>åç¨±:</label>
                    <input type="text" class="individual-name" data-index="${index}" value="${node.name}">
                    <label>é¡è‰²:</label>
                    <input type="color" class="individual-color" data-index="${index}" value="${node.color}">
                `;
                individualList.appendChild(item);
            });
            
            // è¨­ç½®æ•´é«”è¨­å®šçš„é è¨­å€¼
            document.getElementById('overallNameInput').value = '';
            document.getElementById('overallColorInput').value = editingNodes[0].color;
            
            panel.classList.add('active');
            isPanelOpen = true;
        }
        
        function applyOverallSettings() {
            const overallName = document.getElementById('overallNameInput').value.trim();
            const overallColor = document.getElementById('overallColorInput').value;
            
            editingNodes.forEach((node, index) => {
                if (overallName) {
                    node.name = overallName;
                    const nameInput = document.querySelector(`.individual-name[data-index="${index}"]`);
                    if (nameInput) nameInput.value = overallName;
                }
                node.color = overallColor;
                const colorInput = document.querySelector(`.individual-color[data-index="${index}"]`);
                if (colorInput) colorInput.value = overallColor;
            });
            
            draw();
        }
        
        function saveNodeEdits() {
            // æ‡‰ç”¨å€‹åˆ¥ç·¨è¼¯
            editingNodes.forEach((node, index) => {
                const nameInput = document.querySelector(`.individual-name[data-index="${index}"]`);
                const colorInput = document.querySelector(`.individual-color[data-index="${index}"]`);
                
                if (nameInput && nameInput.value.trim()) {
                    node.name = nameInput.value.trim();
                }
                if (colorInput) {
                    node.color = colorInput.value;
                }
            });
            
            saveHistory();
            saveToLocalStorage();
            
            const panel = document.getElementById('editPanel');
            panel.classList.remove('active');
            isPanelOpen = false;
            editingNodes = [];
            draw();
        }
        
        function cancelNodeEdits() {
            const panel = document.getElementById('editPanel');
            panel.classList.remove('active');
            isPanelOpen = false;
            editingNodes = [];
            draw();
        }
        
        // ä¿®æ”¹ drawNodesOnly ä»¥æ”¯æŒæ‹–å‹•åç§»
        function getNodeDragOffset(nodeId) {
            // ç²å–æ°¸ä¹…åç§»
            const permanent = permanentNodeOffsets.get(nodeId) || { x: 0, y: 0 };
            
            // å¦‚æœæ­£åœ¨æ‹–å‹•é€™å€‹ç¯€é»ï¼ŒåŠ ä¸Šç•¶å‰æ‹–å‹•åç§»
            if (isDraggingNode && draggedNode && draggedNode.id === nodeId) {
                const dx = dragCurrent.x - dragNodeStart.x;
                const dy = dragCurrent.y - dragNodeStart.y;
                return { x: permanent.x + dx, y: permanent.y + dy };
            }
            
            return permanent;
        }
        
        function findNodeInTree(nodeId) {
            function search(node) {
                if (node.id === nodeId) return node;
                for (let child of Object.values(node.children)) {
                    const found = search(child);
                    if (found) return found;
                }
                return null;
            }
            return search(rootNode);
        }

        // Enteréµå¿«æ·éµ
        document.getElementById('nodeNameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                finishAddNode();
            }
        });

        // æ§åˆ¶é¢æ¿æŒ‰éˆ•å‡½æ•¸
        function btnAddNode() {
            openAddNodePanel();
        }

        function btnEditNode() {
            if (selectedNodes.size > 0) {
                openEditPanel();
            } else {
                alert('è«‹å…ˆé¸æ“‡è¦ç·¨è¼¯çš„ç¯€é»');
            }
        }

        function btnDeleteNode() {
            openDeleteConfirmation();
        }

        function btnCopy() {
            copyNodes();
            if (selectedNodes.size > 0) {
                showToast('å·²è¤‡è£½ ' + selectedNodes.size + ' å€‹ç¯€é»');
            }
        }

        function btnCut() {
            cutNodes();
            if (selectedNodes.size > 0) {
                showToast('å·²å‰ªä¸‹ ' + selectedNodes.size + ' å€‹ç¯€é»');
            }
        }

        function btnPaste() {
            if (clipboard && clipboard.length > 0) {
                pasteNodes();
                showToast('å·²è²¼ä¸Šç¯€é»');
            } else {
                alert('å‰ªè²¼ç°¿ç‚ºç©º');
            }
        }

        function btnUndo() {
            undo();
            showToast('å·²å¾©åŸ');
        }

        function btnGoBack() {
            if (currentCenterNode.parent) {
                currentCenterNode = currentCenterNode.parent;
                selectedNodes.clear();
                actualSelectedNodes.clear();
                saveHistory();
                saveToLocalStorage();
                draw();
                showToast('è¿”å›ä¸Šå±¤');
            } else {
                alert('å·²åœ¨æœ€ä¸Šå±¤');
            }
        }

        function btnMoveView(direction) {
            const step = 30;
            switch(direction) {
                case 'up':
                    viewOffset.y += step;
                    break;
                case 'down':
                    viewOffset.y -= step;
                    break;
                case 'left':
                    viewOffset.x += step;
                    break;
                case 'right':
                    viewOffset.x -= step;
                    break;
            }
            saveToLocalStorage();
            draw();
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.position = 'fixed';
            toast.style.bottom = '20px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.background = 'rgba(0, 0, 0, 0.8)';
            toast.style.color = 'white';
            toast.style.padding = '10px 20px';
            toast.style.borderRadius = '4px';
            toast.style.zIndex = '3000';
            toast.style.fontSize = '14px';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 2000);
        }
    </script>
</body>
</html>